<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>De-ID Text Inspector (프론트 전용)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- pdf.js (텍스트 추출/미리보기) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
    // 백엔드 붙일 때만 설정: window.API_BASE = 'http://localhost:8787';
  </script>
  <style>
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    mark{ padding: 0 .15rem; border-radius: .2rem; }
  </style>
</head>
<body class="bg-gray-50 text-gray-900">
  <div class="max-w-7xl mx-auto p-6">
    <h1 class="text-2xl font-bold mb-4">🛡️ De-ID Text Inspector (PDF 텍스트 추출·정규화·매칭)</h1>

    <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
      <!-- LEFT: Controls -->
      <div class="bg-white rounded-2xl shadow p-5 space-y-4">
        <div>
          <label class="block text-sm font-semibold mb-1">파일 업로드 (PDF 권장)</label>
          <input id="file" type="file" accept=".pdf,.txt,text/plain" class="block w-full border rounded p-2 bg-white" />
          <p class="text-xs text-gray-500 mt-1">* PDF는 브라우저에서 추출(pdf.js), TXT는 그대로 읽음</p>
        </div>

        <fieldset class="border rounded p-3">
          <legend class="text-sm font-semibold">규칙 선택</legend>
          <label class="block"><input type="checkbox" name="rule" value="rrn" checked> 주민등록번호 (형식+날짜, <span class="text-xs">옵션: 체크섬</span>)</label>
          <label class="block"><input type="checkbox" name="rule" value="phone_mobile" checked> 휴대전화(010)</label>
          <label class="block"><input type="checkbox" name="rule" value="phone_city" checked> 지역전화(02/031~064)</label>
          <label class="block"><input type="checkbox" name="rule" value="email" checked> 이메일</label>
          <label class="block"><input type="checkbox" name="rule" value="card" checked> 카드번호 (Luhn)</label>
          <label class="block"><input type="checkbox" name="rule" value="bizno" checked> 사업자등록번호 (체크섬)</label>
        </fieldset>

        <div class="flex items-center gap-3">
          <label class="inline-flex items-center gap-2"><input id="opt-rrn-checksum" type="checkbox"> 주민번호 체크섬도 검사</label>
          <label class="inline-flex items-center gap-2"><input id="opt-normalize" type="checkbox" checked> 텍스트 정규화 사용</label>
        </div>

        <div class="flex items-center gap-3">
          <button id="btn-scan" class="px-4 py-2 rounded bg-blue-600 text-white">스캔 실행</button>
          <button id="btn-export" class="px-3 py-2 rounded border">리포트 JSON 저장</button>
          <span id="status" class="text-sm text-gray-600"></span>
        </div>

        <div class="border-t pt-3">
          <label class="inline-flex items-center gap-2"><input id="opt-backend" type="checkbox"> 백엔드 사용(API)</label>
          <p class="text-xs text-gray-500">* 체크하면 window.API_BASE로 POST /extract, /match 등을 호출하도록 바꿀 수 있어요 (백엔드 준비되면)</p>
        </div>
      </div>

      <!-- RIGHT: Preview / Results -->
      <div class="lg:col-span-2 space-y-6">
        <div class="bg-white rounded-2xl shadow p-5">
          <h2 class="font-semibold mb-2">PDF 미리보기(1페이지)</h2>
          <canvas id="pdf-preview" class="w-full border rounded"></canvas>
        </div>

        <div class="bg-white rounded-2xl shadow p-5">
          <h2 class="font-semibold mb-2">추출 텍스트 (정규화 적용본 미리보기)</h2>
          <textarea id="txt-out" class="w-full h-48 border rounded p-2 mono" readonly></textarea>
        </div>

        <div class="bg-white rounded-2xl shadow p-5">
          <h2 class="font-semibold mb-2">매칭 결과</h2>
          <div id="summary" class="text-sm text-gray-700 mb-2"></div>
          <div class="overflow-auto">
            <table class="min-w-full text-sm">
              <thead>
                <tr class="border-b">
                  <th class="text-left py-2 px-2">Rule</th>
                  <th class="text-left py-2 px-2">Match</th>
                  <th class="text-left py-2 px-2">Valid</th>
                  <th class="text-left py-2 px-2">Context</th>
                </tr>
              </thead>
              <tbody id="result-rows"></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
/* =========================
   0) 유틸/정규화 (친구 코드 JS 포팅)
   ========================= */
const ZERO_WIDTH = /[\u200B\u200C\u200D\u2060\ufeff]/g;           // 제로폭/제어
const NBSP       = /[\u00A0\u2007\u202F]/g;                        // 특수 공백
const DASHES     = /[\u2010\u2011\u2012\u2013\u2014\u2212\ufe63\u2043]/g; // 대시류
function stripInvisible(s){ return s.replace(ZERO_WIDTH, '').replace(NBSP, ' '); }
function normalizeText(s){
  if(!s) return s;
  s = s.normalize('NFKC');                   // 1) 유니코드 정규화
  s = s.replace(/\r\n?/g, '\n');             // 2) 개행 통일
  s = stripInvisible(s);                     // 3) 보이지 않는 문자 제거
  s = s.replace(DASHES, '-');                // 4) 대시 통일
  s = s.replace(/\t/g, ' ')
       .replace(/[ \f\v]+/g, ' ')
       .split('\n').map(line=>line.replace(/[ \t]+$/,'')).join('\n'); // 5) 공백 정리
  return s;
}
const digitsOnly = s => (s||'').replace(/\D+/g, '');

/* ---------- 검증기 ---------- */
// 주민등록번호
const RRN_RE = /^(\d{6})-([0-9]{7})$/;
function inferCentury(year2, s7){
  if([1,2,5,6].includes(s7)) return 1900 + year2;
  if([3,4,7,8].includes(s7)) return 2000 + year2;
  return null;
}
function validDateYYYYMMDD(yyMMdd, s7){
  const yy = parseInt(yyMMdd.slice(0,2),10);
  const mm = parseInt(yyMMdd.slice(2,4),10);
  const dd = parseInt(yyMMdd.slice(4,6),10);
  const yyyy = inferCentury(yy, s7);
  if(yyyy==null) return false;
  const d = new Date(yyyy, mm-1, dd);
  if(d.getFullYear()!==yyyy || d.getMonth()!==mm-1 || d.getDate()!==dd) return false;
  return d <= new Date();
}
function isValidRRNDateOnly(rrn){
  const m = (rrn||'').match(RRN_RE);
  if(!m) return false;
  const front = m[1], back = m[2]; const s7 = parseInt(back[0],10);
  return validDateYYYYMMDD(front, s7);
}
function isValidRRNChecksum(rrn){
  const m = (rrn||'').match(RRN_RE);
  if(!m) return false;
  const s = (m[1]+m[2]);
  if(s.length!==13 || /\D/.test(s)) return false;
  const digits = [...s].map(c=>c.charCodeAt(0)-48);
  const weights = [2,3,4,5,6,7,8,9,2,3,4,5];
  const total = weights.reduce((acc,w,i)=>acc + digits[i]*w, 0);
  const check = (11 - (total % 11)) % 10;
  return check === digits[12];
}
function isValidRRN(rrn, useChecksum=false){
  if(!isValidRRNDateOnly(rrn)) return false;
  return useChecksum ? isValidRRNChecksum(rrn) : true;
}
// 휴대전화 010
function isValidPhoneMobile(number){
  const d = digitsOnly(number);
  return d.startsWith('010') && d.length===11;
}
// 지역전화
const AREACODE_RE = /^(?:02|0(?:3[1-3]|4[1-4]|5[1-5]|6[1-4]))/;
function isValidPhoneCity(number){
  const d = digitsOnly(number);
  if(!AREACODE_RE.test(d)) return false;
  return d.startsWith('02') ? [9,10].includes(d.length) : [10,11].includes(d.length);
}
// 이메일
const EMAIL_STRICT = /^[A-Za-z0-9._%+-]+@(?:[A-Za-z0-9-]+\.)+[A-Za-z]{2,}$/;
function isValidEmail(addr){ return EMAIL_STRICT.test((addr||'').trim()); }
// 카드 Luhn
function luhnCheck(number){
  const d = digitsOnly(number);
  if(d.length<13 || d.length>19) return false;
  let total=0, dbl=false;
  for(let i=d.length-1;i>=0;i--){
    let n = d.charCodeAt(i)-48;
    if(dbl){ n*=2; if(n>9) n-=9; }
    total+=n; dbl=!dbl;
  }
  return total%10===0;
}
function isValidCard(n){ return luhnCheck(n); }
// 사업자등록번호 체크섬
function isValidBizNo(bno){
  const d = digitsOnly(bno);
  if(d.length!==10) return false;
  const nums = [...d].map(c=>c.charCodeAt(0)-48);
  const ws = [1,3,7,1,3,7,1,3,5];
  let s=0;
  for(let i=0;i<9;i++) s += nums[i]*ws[i];
  s += Math.floor((nums[8]*5)/10);
  const check = (10 - (s % 10)) % 10;
  return check === nums[9];
}

/* ---------- 규칙(정규식) ---------- */
const RULES = {
  rrn:          { id:'rrn',          re: /\b\d{6}-[1-8]\d{6}\b/g,            validate: (s,opts)=>isValidRRN(s, opts.rrnChecksum) },
  phone_mobile: { id:'phone_mobile', re: /\b010[-.\s]?\d{3,4}[-.\s]?\d{4}\b/g, validate: isValidPhoneMobile },
  phone_city:   { id:'phone_city',   re: /\b(?:02|0(?:3[1-3]|4[1-4]|5[1-5]|6[1-4]))[-.\s]?\d{3,4}[-.\s]?\d{4}\b/g, validate: isValidPhoneCity },
  email:        { id:'email',        re: /\b[a-zA-Z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b/g, validate: isValidEmail },
  // 카드: lookbehind 미지원 브라우저 대비, 경계 필터는 코드에서 처리
  card:         { id:'card',         re: /(?:\d[ -]?){13,19}/g,              validate: s => isValidCard(s) },
  bizno:        { id:'bizno',        re: /\b\d{3}-?\d{2}-?\d{5}\b/g,          validate: isValidBizNo },
};

/* =========================
   1) PDF 텍스트 추출 (클라)
   ========================= */
async function extractPdfClient(file){
  const arr = await file.arrayBuffer();
  const pdf = await pdfjsLib.getDocument({data: arr}).promise;
  const pages = [];
  for(let i=1; i<=pdf.numPages; i++){
    const page = await pdf.getPage(i);
    const tc = await page.getTextContent();
    const text = tc.items.map(it => it.str).join(' ');
    pages.push({ pageNumber: i, text });
  }
  const full = pages.map(p => `\n\n===== [Page ${p.pageNumber}] =====\n${p.text}`).join('').replace(/^\s+/, '');
  return { fullText: full, pages, _pdf: pdf };
}

/* =========================
   2) 미리보기
   ========================= */
async function renderPdfPreview(file){
  if(!file || file.type!=='application/pdf') { 
    const c = document.getElementById('pdf-preview'); const g=c.getContext('2d'); g.clearRect(0,0,c.width,c.height); return;
  }
  const arr = await file.arrayBuffer();
  const pdf = await pdfjsLib.getDocument({data: arr}).promise;
  const page = await pdf.getPage(1);
  const viewport = page.getViewport({scale: 1.2});
  const canvas = document.getElementById('pdf-preview');
  canvas.width = viewport.width; canvas.height = viewport.height;
  await page.render({canvasContext: canvas.getContext('2d'), viewport}).promise;
}

/* =========================
   3) 매칭/리포트
   ========================= */
function contextSnippet(s, from, to, pad=30){
  const L = Math.max(0, from-pad), R = Math.min(s.length, to+pad);
  return s.slice(L, from) + '【' + s.slice(from, to) + '】' + s.slice(to, R);
}

function runMatch(text, pickedRules, opts){
  const results = [];
  for(const rid of pickedRules){
    const rule = RULES[rid]; if(!rule) continue;
    const re = new RegExp(rule.re, rule.re.flags.includes('g') ? rule.re.flags : (rule.re.flags+'g'));
    let m;
    while((m = re.exec(text))!==null){
      let val = m[0];
      // 카드 경계 보정: 앞뒤가 숫자면 스킵
      if(rid==='card'){
        const prev = text[m.index-1], next = text[m.index+val.length];
        if((prev && /\d/.test(prev)) || (next && /\d/.test(next))) continue;
      }
      const ok = rule.validate ? !!rule.validate(val, opts): true;
      results.push({ rule: rid, match: val, valid: ok, index: m.index, end: m.index+val.length });
    }
  }
  // 요약
  const counts = pickedRules.reduce((acc, r)=> (acc[r]=results.filter(x=>x.rule===r).length, acc), {});
  return { results, counts };
}

/* =========================
   4) 이벤트/흐름
   ========================= */
const $ = sel => document.querySelector(sel);
const $$ = sel => Array.from(document.querySelectorAll(sel));
$('#file').addEventListener('change', async (e)=>{
  const f = e.target.files[0];
  renderPdfPreview(f).catch(()=>{});
});
$('#btn-scan').addEventListener('click', async ()=>{
  const f = $('#file').files[0];
  if(!f){ alert('파일을 선택하세요'); return; }
  $('#status').textContent = '처리 중...';
  try{
    // 1) 텍스트 추출
    let fullText = '';
    if(f.type==='application/pdf'){ 
      const res = await extractPdfClient(f);
      fullText = res.fullText;
    } else {
      fullText = await f.text();
    }
    // 2) 정규화
    const doNorm = $('#opt-normalize').checked;
    const text = doNorm ? normalizeText(fullText) : fullText;
    $('#txt-out').value = text.slice(0, 100000); // 너무 길면 미리보기만
    // 3) 규칙 선택
    const picked = $$('#'+'frm rules'.replace(' ','')) // dummy to avoid IDE hints
    const pickedRules = $$('input[name="rule"]:checked').map(x=>x.value);
    // 4) 매칭
    const opts = { rrnChecksum: $('#opt-rrn-checksum').checked };
    const { results, counts } = runMatch(text, pickedRules, opts);
    // 5) 테이블 렌더
    const tbody = $('#result-rows'); tbody.innerHTML = '';
    for(const r of results){
      const tr = document.createElement('tr'); tr.className='border-b align-top';
      const tdRule = `<td class="py-2 px-2 mono">${r.rule}</td>`;
      const tdMatch= `<td class="py-2 px-2 mono">${r.match}</td>`;
      const tdValid= `<td class="py-2 px-2 ${r.valid?'text-emerald-700':'text-rose-700'}">${r.valid?'OK':'FAIL'}</td>`;
      const snippet = contextSnippet(text, r.index, r.end, 25).replace(/</g,'&lt;');
      const tdCtx  = `<td class="py-2 px-2 mono">${snippet}</td>`;
      tr.innerHTML = tdRule+tdMatch+tdValid+tdCtx; tbody.appendChild(tr);
    }
    // 6) 요약
    $('#summary').textContent = '검출: ' + Object.entries(counts).map(([k,v])=>`${k}=${v}`).join(', ');
    // 7) 리포트 저장용 전역
    window.__lastReport = { createdAt: new Date().toISOString(), counts, items: results.map(r=>({rule:r.rule, value:r.match, valid:r.valid})) };
    $('#status').textContent = '완료';
  }catch(err){
    console.error(err);
    $('#status').textContent = '오류: ' + (err?.message||err);
  }
});
$('#btn-export').addEventListener('click', ()=>{
  const report = window.__lastReport || {createdAt:new Date().toISOString(), note:'no data'};
  const blob = new Blob([JSON.stringify(report, null, 2)], {type:'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'deid_report.json';
  a.click();
});

/* 백엔드 훅(선택): window.API_BASE가 정의되고 #opt-backend 체크 시
   - /extract (file) -> { full_text, pages[] }
   - /match   (text, rules[], options) -> { counts, items }
   형식을 가정하고 이 부분을 교체하면 됨. 지금은 클라 모드만 활성화. */
</script>
</body>
</html>
